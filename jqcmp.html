<html>
<head>
<script src='./jquery-3.0.0.min.js'></script>
<script>
var variabls = [];
var consts = []
var inr = [];
var umacros = [];

/*
macro "define"-unk-num { def %1% %2% }
macro mem { "" }
macro mem-"="-nummem { "mov %0% %2%" }
macro mem-"+"-num { "add %0% %2%" }
macro mem-"-"-num { "sub %0% %2%" }
macro mem-"--" { "sub %0% 00000001" }
macro mem-"++" { "add %0% 00000001" }
macro mem-"="-"rnd" { "push r0", "rnd", "mov %0% r0", "pop r0" }
macro "rgb"-nummem { "mov r2 %1%", "mov r3 %1%", "mov r4 %1%"}
macro "rgb"-nummem-nummem-nummem { "mov r2 %1%", "mov r3 %2%", "mov r4 %3%"}
macro "goto"-lab|"jump"-lab { "jmp _%1%" }
macro "goxy"-num-num { "mov r0 %1%", "mov r1 %2%"}
macro "ckeys" {?!def CKEYS {"or int 10000000", def CKEYS 1} }
macro "paint" {"pnt"}
macro "paint"-nummem-nummem {"mov r0 %1%", "mov r1 %2%", "pnt"}
macro "point"-nummem-nummem {"mov r0 %1%", "mov r1 %2%"}
macro "rct"-num-num-num-num { "push %1%","push %2%","push %3%","push %4%", "rct" }
macro "turbo"-"on" {"turbo 1"}
macro "turbo"-"off" {"turbo 0"}
macro "rand"-mem { "push r0", "rnd", "mov %1% r0" , "pop r0" }
macro "rand"-mem-mem { "push r0", "rnd", "mov %1% r0", "rnd", "mov %2% r0", "pop r0" }
macro "rand"-mem-mem-mem { "push r0", "rnd", "mov %1% r0", "rnd", "mov %2% r0", "rnd", "mov %3% r0", "pop r0" }

macro "call"-lab { "push pos", "jmp _%1%" }
macro "call"-unk { "<b>Label <code>%1%</code> not found.</b>" }
macro "resv"-num { "push bp", "mov bp sp", "sub sp %1%" }
// I think this is right? Dblchk
macro "retn"-num { "mov sp bp", "pop bp", "pop r7", "pop r6", "add r6 d1", "cmp r6 d0", "snz d1", "add r7 d1", "mov pos r6 r7"}
macro "ret" {"pop r7", "pop r6", "add r6 d1", "cmp r6 d0", "snz d1", "add r7 d1", "mov pos r6 r7"}

//macro "pchar"-num { "mov r7 %1%", "runs charPrint" }

define K_NONE 10000000
define K_NORTH 10000001
define K_WEST 10000010
define K_EAST 10000011
define K_SOUTH 10000100
define K_CNTR 10000101

ext DefASCII
//ext 4X4ASCIIFont
define CHAR__ d32

macro "pushstr"-unk { "push d0", reachchr %1% {"push CHAR_%0%"} }
//macro "print"-unk { "push d0", "pushstr %1%", "call printstr" }

macro "ifkdn"-num-lab|"ifkdn"-mem-lab { "cmp int %1%", "jz _%2%" }
macro "ifeq"-num-num-lab|"ifeq"-mem-num-lab|"ifeq"-num-mem-lab|"ifeq"-mem-mem-lab { "cmp %1% %2%", "jz _%3%" }
macro "setkdn"-num-mem-num { "cmp int %1%", "snz 00000001", "mov %2% %3%" }

ckeys
function main {
  point d10 d10
  rgb d0 d255 d0
  //~turbo d100
  pushstr ABCDEFGHIJKLMNOPQRSTUVWXYZ
  call printstr
  ~mov sp bp
  ~turbo d0

  ~end
}

// I'm lazy, clean up your own stack. ('add sp dStringLen+1' after func ret)
function printstr {
  local curchr
  curchr = d3
  ~:_printstr_lp
  curchr + d1
  ~mov r7 curchr
  ~mov r6 [bp + r7]
  ~cmp r6 d0
  ~jz _printstr_end
  
  call printchr
  ~jmp _printstr_lp
  ~:_printstr_end
}
macro "char4map"-num-mem-num-mem-num {"cmp r6 %1%", "snz d3", "mov %2% %3%", "mov %4% %5%", "jmp _printchr_parts"}
function printchr {
  local prta
  local prtb
  ~cmp r6 d32
  ~snz d2
  ~add r0 d4
  ~jmp _printchr_nd
  char4map CHAR_E prta 11101000 prtb 11001110
  char4map CHAR_T prta 11100100 prtb 01000100
  char4map CHAR_A prta 01001010 prtb 11101010
  char4map CHAR_O prta 11101010 prtb 10101110
  char4map CHAR_I prta 11100100 prtb 01001110
  char4map CHAR_N prta 11001010 prtb 10101010
  char4map CHAR_S prta 01101100 prtb 00101100
  char4map CHAR_H prta 10101010 prtb 11101010
  char4map CHAR_R prta 11001010 prtb 11001010
  char4map CHAR_D prta 11001010 prtb 10101100
  char4map CHAR_L prta 10001000 prtb 10001110
  char4map CHAR_U prta 10101010 prtb 10101110
  char4map CHAR_C prta 01101000 prtb 10000110
  char4map CHAR_M prta 11101110 prtb 10101010
  char4map CHAR_F prta 11101000 prtb 11001000
  char4map CHAR_W prta 10101010 prtb 11101110
  ~mov prta 01001000
  ~mov prtb 00100100
  printchr_parts:
  ~mov r7 d0
  printchr_partalp:
  ~mov r6 prta
  ~shl r6 r7
  ~add r7 d1
  ~and r6 10000000
  ~cmp r6 10000000
  ~snz d1
  ~pnt
  ~add r0 d1
  ~cmp r7 d4
  ~snz d2
  ~sub r0 d4
  ~add r1 d1
  ~cmp r7 d9
  ~jl _printchr_partalp
  ~sub r0 d5
  ~add r1 d1
  ~mov r7 d0
  printchr_partblp:
  ~mov r6 prtb
  ~shl r6 r7
  ~add r7 d1
  ~and r6 10000000
  ~cmp r6 10000000
  ~snz d1
  ~pnt
  ~add r0 d1
  ~cmp r7 d4
  ~snz d2
  ~sub r0 d4
  ~add r1 d1
  ~cmp r7 d9
  ~jl _printchr_partblp
  ~sub r1 d3
  ~sub r0 d1
  printchr_nd:
}

*/


/*
rgb d200 d200 d200
~turbo 1
print WHAT_LETTER_COMES_
print AFTER_
~push r0
rernd:
~rnd
~cmp r0 d25
~jg _rernd
~mov r7 r0
~pop r0
~push d0
~push r7
~runs strPrint
redr:
rgb d0 d0 d0
rct d0 d9 d255 d6
rgb d200 d200 d200
goxy d0 d10
~mov r7 d0
redrlp:
~add r7 d1
~push r7
~runs charPrint
~pop r7
~cmp r7 d26
~jnz _redrlp
~mov r7 $sel$
~mov r6 d0
~mov r0 d0
mvtohl:
~cmp r6 r7
~jz _mvdhl
~add r6 d1
~add r0 d4
~jmp _mvtohl
mvdhl:
~sub r1 d1
~push r0
~push r1
~push d4
~push d5
~rct
~add r1 d1
~mov r7 $sel$
rgb d50 d50 d50
~add r7 d1
~runs charPrint
~mov r7 $sel$
kywt:
ifkdn K_NONE kywt
ifkdn K_EAST incsel
ifkdn K_WEST decsel
goto kywt
incsel:
$sel$ ++
goto redr
decsel:
$sel$ --
goto redr
*/

var defaultCdin = `macro "define"-unk-num { def %1% %2% }
macro mem { "" }
macro mem-"="-nummem { "mov %0% %2%" }
macro mem-"+"-num { "add %0% %2%" }
macro mem-"-"-num { "sub %0% %2%" }
macro mem-"--" { "sub %0% 00000001" }
macro mem-"++" { "add %0% 00000001" }
macro mem-"="-"rnd" { "push r0", "rnd", "mov %0% r0", "pop r0" }
macro "rgb"-nummem { "mov r2 %1%", "mov r3 %1%", "mov r4 %1%"}
macro "rgb"-nummem-nummem-nummem { "mov r2 %1%", "mov r3 %2%", "mov r4 %3%"}
macro "goto"-lab|"jump"-lab { "jmp _%1%" }
macro "goxy"-num-num { "mov r0 %1%", "mov r1 %2%"}
macro "ckeys" {?!def CKEYS {"or int 10000000", def CKEYS 1} }
macro "paint" {"pnt"}
macro "paint"-nummem-nummem {"mov r0 %1%", "mov r1 %2%", "pnt"}
macro "point"-nummem-nummem {"mov r0 %1%", "mov r1 %2%"}
macro "rct"-num-num-num-num { "push %1%","push %2%","push %3%","push %4%", "rct" }
macro "turbo"-"on" {"turbo 1"}
macro "turbo"-"off" {"turbo 0"}
macro "rand"-mem { "push r0", "rnd", "mov %1% r0" , "pop r0" }
macro "rand"-mem-mem { "push r0", "rnd", "mov %1% r0", "rnd", "mov %2% r0", "pop r0" }
macro "rand"-mem-mem-mem { "push r0", "rnd", "mov %1% r0", "rnd", "mov %2% r0", "rnd", "mov %3% r0", "pop r0" }

macro "call"-lab { "push pos", "jmp _%1%" }
macro "call"-unk { "<b>Label <code>%1%</code> not found.</b>" }
macro "resv"-num { "push bp", "mov bp sp", "sub sp %1%" }
// I think this is right? Dblchk
macro "retn"-num { "mov sp bp", "pop bp", "pop r7", "pop r6", "add r6 d1", "cmp r6 d0", "snz d1", "add r7 d1", "mov pos r6 r7"}
macro "ret" {"pop r7", "pop r6", "add r6 d1", "cmp r6 d0", "snz d1", "add r7 d1", "mov pos r6 r7"}

define K_NONE 10000000
define K_NORTH 10000001
define K_WEST 10000010
define K_EAST 10000011
define K_SOUTH 10000100
define K_CNTR 10000101

ext DefASCII
//ext 4X4ASCIIFont
define CHAR__ d32

macro "pushstr"-unk { "push d0", reachchr %1% {"push CHAR_%0%"} }

macro "ifkdn"-num-lab|"ifkdn"-mem-lab { "cmp int %1%", "jz _%2%" }
macro "ifeq"-num-num-lab|"ifeq"-mem-num-lab|"ifeq"-num-mem-lab|"ifeq"-mem-mem-lab { "cmp %1% %2%", "jz _%3%" }
macro "setkdn"-num-mem-num { "cmp int %1%", "snz 00000001", "mov %2% %3%" }`;

function parselines(alltxt){
	var otlns = [];
	var parss = "";
	var dpth = 0;
	while (alltxt.length > 0){
		parss += alltxt[0]; alltxt = alltxt.substr(1,alltxt.length-1);
		// Handle Depth
		if (alltxt[0] == "{") dpth++;
		if (alltxt[0] == "}") dpth--;
		if (dpth < 1) {
			if (alltxt[0] == "\n" && parss.length > 0) {otlns.push(parss.trim()); parss = "";}
		}
	}
	if (parss.trim().length > 0) { otlns.push(parss.trim()); } //console.log(otlns);
	return otlns;
}
function parsePcs(txti){
	var otlns = [];
	var parss = "";
	var dpth = 0;
	for (var idx = 0; idx < txti.length; idx++){
		parss += txti[idx];
		if (txti[idx] == "(" || txti[idx] == "{" || txti[idx] == "[") dpth++;
		if (txti[idx] == ")" || txti[idx] == "}" || txti[idx] == "]") dpth--;
		if (dpth == 0 && txti[idx+1] == " ") {otlns.push(parss); parss = ""; idx++;}
	}
	if (parss.trim().length > 0) otlns.push(parss.trim());
	//if (txti.indexOf("(") > 0) { console.log("in> " + txti); console.log(otlns); }
	if (dpth != 0) pout("<b>Mismatched brackets: <code>" + txti + "</code></b>")
	return otlns;
}

function addmacro(expr, cmd){
	var newmac = {};
	newmac.expr = [];
	var exprs = expr.match(/[^|]+/g);
	for (var idx = 0; idx < exprs.length; idx++)
		newmac.expr.push(exprs[idx].match(/("\-+")|([^-]+)/g));
	if (typeof(cmd) == "function"){
		newmac.domacro = cmd;
	} else {
		newmac.cmds = parseMacroCmd(cmd);
		newmac.domacro = outputMacro;
	}
	newmac.mactch = macroMatches;
	//console.log(newmac);
	umacros.push(newmac);
}

function exprMatch(expres, ttm){
	if (expres.length != ttm.length) return false;
	for (var idx = 0; idx < ttm.length; idx++){
		if (expres[idx].startsWith("\"") & expres[idx].endsWith("\"")){ if (expres[idx].substr(1, expres[idx].length-2) != ttm[idx]) return false; }
		else if (structure(ttm[idx])[0] == expres[idx]){ }
		else if (expres[idx] == "nummem") { if (structure(ttm[idx])[0] != "num" & structure(ttm[idx])[0] != "mem") return false; }
		else { return false; }
	}
	//console.warn("mactch");
    //console.warn(expres);console.warn(ttm);
	return true;
}

function macroMatches(ttm){
	for (var idx = 0; idx < this.expr.length; idx++){
		if (exprMatch(this.expr[idx], ttm)) return true;
	}
	return false;
}

function parseMacroCmd(cmd){
	var otlns = [];
	var parstr = "";
	var dept = 0;
	for (var ix = 0; ix < cmd.length; ix++){
		if (cmd[ix] == "{") { dept++; if (dept > 1) parstr += cmd[ix]; }
		else if (cmd[ix] == "}") { if (dept < 2) {otlns.push(parstr.trim()); parstr = "";} else { dept--; parstr += cmd[ix];} }
		else if (cmd[ix] == ",") { if (dept < 2) {otlns.push(parstr.trim()); parstr = "";} else { parstr += cmd[ix]; } }
		else {parstr += cmd[ix]}
	}
	//console.warn(otlns);
	return otlns;
}


function opmac_repa(cpcs, pcs){
	for (var idx in cpcs){
		for (var idy in pcs){
			cpcs[idx] = cpcs[idx].replace ("%" + idy + "%", pcs[idy]);
		}
	}
	return cpcs;
}
function opmac_repl(tcmd, pcs){
	for (var idx = 0; idx < pcs.length; idx++){
		while(tcmd.indexOf("%strlen_"+idx+"%") > -1) tcmd = tcmd.replace("%strlen_"+idx+"%", pcs[idx].length+1);
		while(tcmd.indexOf("%len_"+idx+"%") > -1) tcmd = tcmd.replace("%len_"+idx+"%", pcs[idx].length);
		while(tcmd.indexOf("%blklen_"+idx+"%") > -1) tcmd = tcmd.replace("%blklen_"+idx+"%", countBlockLines(outputMacroBlock(pcs[idx])));
		while(tcmd.indexOf("%blk_"+idx+"%") > -1) tcmd = tcmd.replace("%blk_"+idx+"%", outputMacroBlock(pcs[idx]).join("<br>"));
		while(tcmd.indexOf("%"+idx+"%") > -1) tcmd = tcmd.replace("%"+idx+"%", pcs[idx]);
	}
	return tcmd;
}

function outputMacro_I(tcmds, pcs){
	var ottxt = [];
	for (var idx in tcmds){
		var tcmd = tcmds[idx];
		var cpcs = parsePcs(tcmd);
		var toout = [];
		if (tcmd.startsWith("\"") & tcmd.endsWith("\"")){ tcmd = tcmd.substr(1, tcmd.length-2); tcmd = opmac_repl(tcmd, pcs); toout.push(tcmd); }
		else if (cpcs[0] == "rpt") { cpcs = opmac_repa(cpcs, pcs); for (var idy = 0; idy < numVal(cpcs[1]); idy++){ toout = toout.concat(outputMacro_I(parseMacroCmd(cpcs[2]), pcs)); } }
		else if (cpcs[0] == "def") { cpcs = opmac_repa(cpcs, pcs); consts[cpcs[1]] = cpcs[2]; }
		else if (cpcs[0] == "?def") { if (cpcs[1] in consts) toout = outputMacro_I(parseMacroCmd(cpcs[2]),pcs); }
		else if (cpcs[0] == "?!def") { if (!(cpcs[1] in consts)) toout = outputMacro_I(parseMacroCmd(cpcs[2]),pcs); }
		else if (cpcs[0] == "eachchr") { for (var idy = 0; idy < pcs[1].length; idy++) toout.push(outputMacro_I(parseMacroCmd(cpcs[2]),pcs[1][idy])); }
		else if (cpcs[0] == "reachchr") { for (var idy = pcs[1].length -1; idy >= 0; idy--) toout.push(outputMacro_I(parseMacroCmd(cpcs[2]),pcs[1][idy])); }
		else { 
			var isMacro = false;
			cpcs = opmac_repa(cpcs, pcs);
			for (var midx in umacros){
				if (umacros[midx].mactch(cpcs)){ isMacro = true; var ttpadd = umacros[midx].domacro(cpcs); ottxt.push(ttpadd); console.log(ttpadd); }
			}
			if (!isMacro){ pout("<b>Unhandled macro command: <code>" + tcmd + "</code></b>"); console.log(pcs); }
		}
		
		
		for (var lidx in toout){
			lnpcs = parsePcs(toout[lidx]);
			var matched = false;
			for (var midx in umacros){
				if (umacros[midx].mactch(lnpcs)) { matched = true; /*ottxt.concat(umacros[midx].domacro(lnpcs));*/ }
				// This is wrong. It must have a loop which sees if any macros can be run, and run them until none can be run.
				// This will work around the callstack limit.
			}
			if (!matched) ottxt.push(doCnst(toout[lidx]));
		}
		//if (tcmd == "call printStr") console.warn(ottxt);
	}
	//pout("<span class='instr' title='" + pcs.join(" ") + "'>" + ottxt.join("<br>") + "</span>");
	/*for (var idx in ottxt){
		for (var midx in umacros){
			if (umacros[midx].match(ottxt[idx])) { umacros.domacro(ottxt); }
		}
	}*/
	//for (var midx = 0; midx < umacros.length; midx++){
	//	if (umacros[midx].mactch(pcs)) { umacros[midx].domacro(pcs); return; }
	//}
	//console.log(ottxt);
	return ottxt;
}
function outputMacro(pcs){ 
	var mout = outputMacro_I(this.cmds, pcs);
	if (mout.length > 0) return "<span class='instr' title='" + pcs.join(" ") + "'>" + mout.join("<br>") + "</span>";
	return "";
}
function outputMacroBlock(mblk){
	var blklns = parselines(mblk.substr(1,mblk.length-2).trim());
	var ttwo = [];
	var macroaccepted = false;
	for (var idz = 0; idz < blklns.length; idz++){
	    blklns[idz] = doCnst(blklns[idz]);
		if (blklns[idz].trim().length < 1) { }
		else if (blklns[idz].startsWith("~")) { ttwo.push(blklns[idz].substr(1)); macroaccepted = true; } 
		else {
			var strc = structure(blklns[idz]).join("-");
			var pcs = parsePcs(blklns[idz]);
	
			for (var midx = 0; midx < umacros.length; midx++)
				if (umacros[midx].mactch(pcs)) { var ttpo = umacros[midx].domacro(pcs); if (ttpo.length > 0) ttwo.push(ttpo); macroaccepted = true; }
		}
		if (!macroaccepted) { ttwo.push("<strong>Unrecognized block string: "+ blklns[idz] +"</strong>"); }
	}
	
	return ttwo;
}
function countBlockLines(mblk){
    mblk = mblk.join("<br>").replace(/(\<\/*span[^\>]*\>)/ig,"").replace(/(\<br\s*\/*\>)/ig, "\r\n").trim();
	mblk = mblk.split("\n");
	return mblk.length;
}


function addfunc(funcnam, funcstr) {
	var funclns = parselines(funcstr.substr(1, funcstr.length-2).trim());
	var fobj = {nam: funcnam, lns: [], lvrs: [], pvrs: [], hasVar: fobj_hasvar};
	
	for (var idz=0; idz < funclns.length; idz++) hfuncln(fobj, funclns[idz]);
	
	//pout("// Function " + funcnam + " with " + fobj.lvars + " local variable" + (fobj.lvars == 1 ? "" : "s") + ".");
	pout(":_" + funcnam);
	pout("push bp")
	pout("mov bp sp")
	if (fobj.lvrs.length > 0) pout("sub sp d" + fobj.lvrs.length);
	for (idz = 0; idz < fobj.lns.length; idz++){
	    pout(fobj.lns[idz]);
	}
	
	pout ("mov sp bp");
	pout("pop bp");
	
	handleln("ret");
	// ret
	/*pout("pop r7");
	pout("pop r6");
	pout("add r6 d1");
	pout("cmp r6 d0");
	pout("snz d1");
	pout("add r7 d1");
	pout("mov pos r6 r7");*/
}

function hfuncln(fobj, lth){
	if (lth.length < 1) return;
	if (lth.startsWith("//")) return;
	if (lth.substr(-1,1) == ":" & lth.length > 1 & lth.indexOf(" ") < 0) { fobj.lns.push(":_"+lth.replace(":","")); return;}
	lth = doCnst(lth);
	
	for (var vdx = 0; vdx < fobj.lvrs.length; vdx++){
	    var dontoverflow = 100;
		//console.log("replacing " + fobj.lvrs[vdx].nam + " = d" + vdx);
		while (lth.indexOf(fobj.lvrs[vdx].nam) > -1 & dontoverflow-- > 0){
			lth = lth.replace("*"+fobj.lvrs[vdx].nam, "d" + vdx );
			lth = lth.replace(fobj.lvrs[vdx].nam, "[bp - d" + vdx + "]");
		}
	}
	for (var vdx = 0; vdx < fobj.pvrs.length; vdx++){
	    var dontoverflow = 100;
		//console.log("replacing " + fobj.lvrs[vdx].nam + " = d" + vdx);
		while (lth.indexOf(fobj.pvrs[vdx].nam) > -1 & dontoverflow-- > 0){
			lth = lth.replace("*"+fobj.pvrs[vdx].nam, "d" + fobj.pvrs[vdx].loc );
			lth = lth.replace(fobj.pvrs[vdx].nam, fobj.pvrs[vdx].loc);
		}
	}
	
	if (lth.substr(0,1) == "~") { fobj.lns.push(lth.substr(1)); return;}
	var strc = structure(lth).join("-");
	var pcs = parsePcs(lth);
	
	for (var midx = 0; midx < umacros.length; midx++)
		if (umacros[midx].mactch(pcs)) { var ttpo = umacros[midx].domacro(pcs); if (ttpo.length > 0) fobj.lns.push(ttpo); return; }
	if (pcs[0] == "local" & pcs.length == 2){
		if (fobj.hasVar(pcs[1])) { fobj.lns.push("<b>Local variable <code>" + pcs[1] + "</code> already declared</b>"); return;}
		fobj.lvrs.push({ nam: pcs[1] });
		return;
	}
	if (pcs.length > 3){
		if (pcs[0] == "local" & pcs[2] == "@" & pcs.length == 4){
			if (fobj.hasVar(pcs[1])) { fobj.lns.push("<b>Local variable <code>" + pcs[1] + "</code> already declared</b>"); return;}
			fobj.pvrs.push({ nam: pcs[1], loc: pcs[3] });
			return;
		}
	}
	
	fobj.lns.push("<b>Cannot parse line: <code>" + lth + "</code> of structure ("+strc+")</b>");
}

function fobj_hasvar(varnam){
	for (var vdx = 0; vdx < this.lvrs.length; vdx++){
		if (this.lvrs[vdx].nam == varnam) return true;
	}
	for (var vdx = 0; vdx < this.pvrs.length; vdx++){
		if (this.pvrs[vdx].nam == varnam) return true;
	}
	return false;
}




function setr(rnum, vnams){
	if (typeof(rnum) === "number") rnum = "r" + rnum;
	inr[rnum] = vnams;
	//console.warn(inr[rnum]);
}

function movr(rnum, nnum){
	if (typeof(rnum) === "number") rnum = "r" + rnum;
	if (inr[rnum] === undefined){ inr[rnum] = ""; }
	//console.log("inr: " + inr[rnum]);
	//console.log("nnm: " + nnum);
	if ($.isNumeric(nnum)) nnum = "d" + nnum;
	if (inr[rnum].indexOf(nnum) < 0)
		{ setr(rnum, nnum); pout("mov " + rnum + " " + nnum); }
}
function pout(ttpo){
	$("#outdiv").html($("#outdiv").html()+"<br>"+ttpo);
}

function mk8d(incd){
	while (incd.length < 8) incd = "0" + incd;
	return incd;
}

function deval(eval){
	eval = eval.substr(1,eval.length-2);
	var cmps = parsePcs(eval);
	var strc = structure(eval);
	var rpl = "r6"; var rpr = "r7";
	if (strc[0] == "mem") { movr(6, cmps[0]); }
	else if (strc[0] == "num") { rpl = cmps[0]; }
	else { pout("Unhandled eval type: " + strc[0]); }
	if (strc[2] == "mem") { movr(7, cmps[2]); }
	else if (strc[2] == "num") { rpr = cmps[2]; }
	else { pout("Unhandled eval type: " + strc[2]); }
	console.warn(cmps);
	console.log(strc);
	if (cmps[1] == "="){
		pout("cmp " + rpl + " " + rpr);
	}else{
		// Not an equality comparator
	}
}

function oper_mon(ml, opr, nta){
	if (opr == "="){
		pout("mov " + ml + " " + nta.toString(2));
	} else if (opr == "+"){
		pout("add " + ml + " " + nta.toString(2));
	}else if (opr == "-"){
		pout("sub " + ml + " " + nta.toString(2));
	}else {
		pout("<b>Unhandled Operator: " + opr + "</b>");
	}
}
function oper_mom(ml, opr, nta){
	
	if (opr == "+"){
		movr(7, nta);
		pout("add " + ml + " r7");
	} else {
		pout("<b>Unhandled Operator: " + opr + "</b>");
	}
}
function goto_lab(labl){
	var nlab = "_"+labl;
	if ($("#cdin").val().indexOf(labl+":") < 0) { pout("<b>Label does not exist: <code>" + labl + "</code></b>"); }
	pout("jmp " + nlab);
}
function if_iekl(cndtn, kwd, finl){
	if (kwd.toLowerCase() == "goto") { if_iegl(cndtn, finl); return; }
	pout ("<b>Unrecognized IF structure: <code>" + kwd + " " + finl + "</code></b>");
}
function if_iegl(cndtn, labl){
	var eval = cndtn.substr(1,cndtn.length-2);
	var cmps = parsePcs(eval);
	var strc = structure(eval);
	var rpl = "r6"; var rpr = "r7";
	if (strc[0] == "mem") { movr(6, cmps[0]); }
	else if (strc[0] == "num") { rpl = "d" + cmps[0]; }
	else { pout("<b>Unhandled eval type: <code>" + strc[0] + "</code></b>"); }
	if (strc[2] == "mem") { movr(7, cmps[2]); }
	else if (strc[2] == "num") { rpr = "d" + cmps[2]; }
	else { pout("<b>Unhandled eval type: <code>" + strc[2] + "</code></b>"); }
	if (cmps[1] == "="){
		pout("cmp " + rpl + " " + rpr);
		pout("jz _" + labl);
	} else if (cmps[1] == "<"){
		pout("cmp " + rpl + " " + rpr);
		pout("jl _" + labl);
	} else if (cmps[1] == ">"){
		pout("cmp " + rpl + " " + rpr);
		pout("jg _" + labl);
	} else {
		pout("<b>Unhandled if operator: " + cmps[1] + "</b>");
		// Not an equality comparator
	}
}

function dpnt(xat, yat){
	var strc = structure(xat + " " + yat);
	movr(0, xat);
	movr(1, yat);
	pout("pnt");
}
function drgb(nr, ng, nb){
	movr(2, nr);
	movr(3, ng);
	movr(4, nb);
}
function drct(x1, y1, x2, y2){
	movr(7, x1);
	pout("push r7");
	movr(7, y1);
	pout("push r7");
	movr(7, x2);
	pout("push r7");
	movr(7, y2);
	pout("push r7");
	pout("rct")
}

function numVal(ntg){
	if (typeof(ntg) == "number") return ntg;
	if (typeof(ntg) == "string") {
		if (isBinary(ntg)){
			return parseInt(ntg, 2);
		} else if (ntg.startsWith("d")){
			return parseInt(ntg.substr(1), 10);
		} else {
			console.warn ("Not a valid value: " + ntg);
		} 
	} else {
		console.warn ("Invalid number type to convert.");
	}
}

function isBinary(numstr){
	if (typeof(numstr) != "string") { console.warn(typeof(numstr)); }
	if (numstr.length != 1 && numstr.length != 8) return false;
	for (var idx = 0; idx < numstr.length; idx++){
		if (numstr[idx] != "0" & numstr[idx] != "1") return false;
	}
	return true;
}

function structure(lth){
	lth = parsePcs(lth);
	
	for (var idx = 0; idx < lth.length; idx++){
		var tcm = lth[idx];
		if (tcm.startsWith("[") & tcm.endsWith("]")){
			lth[idx] = "mem";
		} else if(tcm.startsWith("d") & $.isNumeric(tcm.substr(1)) || isBinary(tcm)){
			lth[idx] = "num";
		} else if(tcm == "+" | tcm == "-" | tcm == "*" | tcm == "/" | tcm == "="){
			lth[idx] = "oper";
		} else if(tcm.toLowerCase() == "if"){
			lth[idx] = "if";
		} else if (tcm.substr(0,1) == "(" && tcm.substr(-1) == ")"){
			lth[idx] = "eval";
		} else if (tcm.substr(0,1) == "{" && tcm.substr(-1) == "}"){
			lth[idx] = "blk";
		} else if ($("#cdin").val().indexOf(tcm+":") > -1){
			lth[idx] = "lab";
		} else if ($("#cdin").val().indexOf("function " + tcm + " ") > -1){
			lth[idx] = "lab";
		} else {
			lth[idx] = "unk";
		}
	}
	return lth;
}

function doCnst(lth){
	if (typeof(lth) == "string"){
		for (var cnst in consts){
			lth = lth.replace(cnst, consts[cnst]);
		}
	} else if (Array.isArray(lth)) {
		for (var lnx = 0; lnx < lth.length; lnx++)
			lth[lnx] = doCnst(lth[lnx]);
	}else { pout("Non-string passed to doCnst!"); }
	return lth;
}
function handleln(lth){
	if (lth.length < 1) return;
	if (lth.startsWith("//")) return;
	lth = doCnst(lth);
	if (lth.substr(0,1) == "~") { pout (lth.substr(1)); return;}
	var strc = structure(lth).join("-");
	var pcs = parsePcs(lth);
	if (pcs[0] == "macro") { addmacro(pcs[1], pcs[2]); return; }
	if (pcs[0] == "function" && pcs.length == 3) { addfunc(pcs[1], pcs[2]); return; }
	for (var midx = 0; midx < umacros.length; midx++)
		if (umacros[midx].mactch(pcs)) { var ttpo = umacros[midx].domacro(pcs); if (ttpo.length > 0) pout(ttpo); return; }
	
	
	if (pcs[0] == "getInputC") { mac_getInpC(pcs); return; }
	if (pcs[0] == "ext") { doExtended(pcs); return; }
		
	
	if (pcs[0].substr(-1,1) == ":" && pcs[0].length > 1) { pout(":_"+pcs[0].replace(":","")); inr = []; return;}
	pout ("<b>Cannot parse line: <code>" + lth + "</code> of structure ("+strc+")</b>");
}

function stcd(){
	var incode = $("#cdin").val().replace("<script", "");
	variabls = []; inr = []; umacros = []; consts = [];
	/*var varis = incode.match(/(\$)\w+(\$)/g);
	if (varis != null)
	for (var idx = 0; idx < varis.length; idx++){
		if (variabls.indexOf(varis[idx]) < 0){
			variabls.push(varis[idx]);
			while (incode.indexOf(varis[idx]) >= 0) { incode = incode.replace(varis[idx],"#"+mk8d(idx.toString(2))); }
			var varptr = varis[idx].substr(0,varis[idx].length-1) + "*$";
			while (incode.indexOf(varptr) >= 0) { incode = incode.replace(varptr, mk8d(idx.toString(2))); }
		}
	}*/
	
	var codelines = parselines(incode);
	
	$("#outdiv").html("");
	for (var clidx = 0; clidx < codelines.length; clidx++){
		handleln(codelines[clidx]);
		//$("#outdiv").html($("#outdiv").html()+"<br>"+codelines[clidx]);
	}
	localStorage["restoreText"] = $("#outdiv").html().replace(/(\<\/*span[^\>]*\>)/ig,"").replace(/(\<br\s*\/*\>)/ig, "\r\n").trim();
}

function doExtended(pcs){
	if (pcs[1] == "DefChars") { ext_DefChars(); return; }
	if (pcs[1] == "DefASCII") { ext_DefASCII(); return; }
	if (pcs[1] == "Def4x4ASCIIFont") { ext_DefASCIIFont(); return; }
	if (pcs[1] == "Strings") { ext_Strings(); return; }
	pout ("Unrecognized extended macro: " + pcs.join(" "));
}

function ext_DefChars(){
	for (i = 65; i < 91; i++){
		consts["CHAR_" + String.fromCharCode(i)] = "d" + (i - 64).toString();
		//console.warn(String.fromCharCode(i));
	}
}
function ext_DefASCII(){
	for (i = 65; i < 91; i++){
		consts["CHAR_" + String.fromCharCode(i)] = "d" + (i).toString();
		//console.warn(String.fromCharCode(i));
	}
}

function mac_getInpC(pcs){
	var codelns = parselines($("#cdin").val());
	if (pcs.length == 2){
		var prefx = pcs[1];
		
		var pstfx = "_none";
		if (codelns.indexOf(prefx + pstfx + ":") > -1){ pout("cmp int 10000000"); pout("jz _" + prefx + pstfx); }
		pstfx = "_up";
		if (codelns.indexOf(prefx + pstfx + ":") > -1){	pout("cmp int 10000001"); pout("jz _" + prefx + pstfx); }
		pstfx = "_dn";
		if (codelns.indexOf(prefx + pstfx + ":") > -1){	pout("cmp int 10000100"); pout("jz _" + prefx + pstfx); }
		pstfx = "_lft";
		if (codelns.indexOf(prefx + pstfx + ":") > -1){	pout("cmp int 10000010"); pout("jz _" + prefx + pstfx); }
		pstfx = "_rgt";
		if (codelns.indexOf(prefx + pstfx + ":") > -1){	pout("cmp int 10000011"); pout("jz _" + prefx + pstfx); }
		pstfx = "_ctr";
		if (codelns.indexOf(prefx + pstfx + ":") > -1){	pout("cmp int 10000101"); pout("jz _" + prefx + pstfx); }
	}
	
}

$(function(){
	if (localStorage["cdincmp"] === undefined){
	
	} else {
		$("#cdin").val(localStorage["cdincmp"]);
	}
	
	if ($("#cdin").val().length < 1) $("#cdin").val(defaultCdin);
	
	$("#cdin").keyup(function(){
		localStorage["cdincmp"] = $("#cdin").val();
		$("#outdiv").html("<div align='center' style='color:#AA0000'>Please Compile</div>");
		//stcd();
	});
});
</script>
<style>
span.instr:hover {
	background-color: yellow;
}
</style>
</head>
<body>
<div align='center'><input type='button' onclick='stcd();' value='Compile'/></div>
<textarea id='cdin' style='width:100%; height:200px;'></textarea>
<div id='outdiv'></div>
</body>
</html>

<!--
~rnd
~mov $TARGX$ r0
~rnd
~mov $TARGY$ r0
~rnd
~mov $TARGCR$ r0
~rnd
~mov $TARGCG$ r0
~rnd
~mov $TARGCB$ r0
~rnd
~mov $TILCLR$ r0
lp:
rgb 0 0 0
~mov r5 d10
~push 00000001
~push 00000001
~push 11111111
~push 11111111
~rcta
rgb $CR$ $CG$ $CB$
pnt $X$ $Y$
~turbo 0
~turbo 1
~mov $RET$ posl
~mov r6 $X*$
~mov r7 $TARGX*$
GOTO dcmp
~mov $RET$ posl
~mov r6 $Y*$
~mov r7 $TARGY*$
GOTO dcmp
~mov $RET$ posl
~mov r6 $CR*$
~mov r7 $TARGCR*$
GOTO dcmp
~mov $RET$ posl
~mov r6 $CG*$
~mov r7 $TARGCG*$
GOTO dcmp
~mov $RET$ posl
~mov r6 $CB*$
~mov r7 $TARGCB*$
GOTO dcmp
GOTO lp
dcmp:
~cmp #r6 #r7
~jz _ntarg
~jg _movup
~jl _movdn
aftmov:
$RET$ + 3
~mov r7 $RET$
~jmp r7 
GOTO lp
ntarg:
~push r0
~rnd
~mov #r7 r0
~pop r0
GOTO aftmov
movdn:
~add #r6 1
GOTO aftmov
movup:
~sub #r6 1
GOTO aftmov





~nop RainAmt: (max 128)
~mov r7 d10
~nop More rain will also make it fall slower
~sub r7 00000001
~shl r7 d1
rgb 255 255 255
initlp:
~turbo 1
~rnd
~mov #r1 r0
~cmp r1 r7
~add r1 d1
~turbo 0
~jz _lp
goto initlp
lp:
goto dodrp
alp:
~cmp r6 11111110
~jnz _lp
~mov r6 r7
rgb 0 0 0
~mov r5 d80
~push 0
~push 0
~push d255
~push d255
~rcta
rgb 100 180 255
~turbo 0
~turbo 1
goto lp
dodrp:
~cmp #r6 11111111
~jz _newlc 
~add #r6 d1
~mov r1 #r6
~mov r0 r6
~add r0 d1
~mov r0 #r0
~pnt
~sub r6 d2
goto alp
newlc:
~add r6 d1
~rnd
~mov #r6 r0
~sub r6 d1
~mov #r6 00000000
goto alp
-->







<!--
macro "define"-unk-num { def %1% %2% }
macro mem { "" }
macro mem-"="-nummem { "mov %0% %2%" }
macro mem-"+"-num { "add %0% %2%" }
macro mem-"-"-num { "sub %0% %2%" }
macro mem-"--" { "sub %0% 00000001" }
macro mem-"++" { "add %0% 00000001" }
macro mem-"="-"rnd" { "push r0", "rnd", "mov %0% r0", "pop r0" }
macro "rgb"-nummem { "mov r2 %1%", "mov r3 %1%", "mov r4 %1%"}
macro "rgb"-nummem-nummem-nummem { "mov r2 %1%", "mov r3 %2%", "mov r4 %3%"}
macro "goto"-lab|"jump"-lab { "jmp _%1%" }
macro "goxy"-num-num { "mov r0 %1%", "mov r1 %2%"}
macro "ckeys" {?!def CKEYS {"or int 10000000", def CKEYS 1} }
macro "paint" {"pnt"}
macro "clear" {"clr"}
macro "paint"-nummem-nummem {"mov r0 %1%", "mov r1 %2%", "pnt"}
macro "point"-nummem-nummem {"mov r0 %1%", "mov r1 %2%"}
macro "rct"-num-num-num-num { "push %1%","push %2%","push %3%","push %4%", "rct" }
macro "lin"-num-num-num-num { "push %1%","push %2%","push %3%","push %4%", "lin" }
macro "turbo"-"on" {"turbo 1"}
macro "turbo"-"off" {"turbo 0"}
macro "rand"-mem { "push r0", "rnd", "mov %1% r0" , "pop r0" }
macro "rand"-mem-mem { "push r0", "rnd", "mov %1% r0", "rnd", "mov %2% r0", "pop r0" }
macro "rand"-mem-mem-mem { "push r0", "rnd", "mov %1% r0", "rnd", "mov %2% r0", "rnd", "mov %3% r0", "pop r0" }

macro "call"-lab { "push pos", "jmp _%1%" }
macro "call"-lab-nummem { "mov r7 %2%", call %1% }
macro "call"-lab-nummem-nummem { "mov r6 %2%", "mov r7 %3%", call %1% }
macro "call"-unk { "<b>Label <code>%1%</code> not found.</b>" }
macro "callz"-lab { "snz d2", "push pos", "jmp _%1%" }
macro "resv"-num { "push bp", "mov bp sp", "sub sp %1%" }
// I think this is right? Dblchk. (Checked, seems to work great.)
macro "retn"-num { "mov sp bp", "pop bp", "pop r7", "pop r6", "add r6 d1", "cmp r6 d0", "snz d1", "add r7 d1", "mov pos r6 r7"}
macro "ret" { "jmp _funcrtn" }
macro "rtInt" {"pop r7", "pop r6", "add r6 d1", "cmp r6 d0", "snz d1", "add r7 d1", "mov pos r6 r7"}

//macro "pchar"-num { "mov r7 %1%", "runs charPrint" }

define KC_NONE 10000000
define KC_NORTH 10000001
define KC_WEST 10000010
define KC_EAST 10000011
define KC_SOUTH 10000100
define KC_CNTR 10000101
define K_NONE 00000000
define K_NORTH 00000001
define K_WEST 00000010
define K_EAST 00000011
define K_SOUTH 00000100
define K_CNTR 00000101

ext DefASCII
//ext 4X4ASCIIFont
define CHAR__ d32
define CHAR_. d46
define CHARGT d63
define CHARLT d64

macro "pushstr"-unk { "push d0", reachchr %1% {"push CHAR_%0%"} }
macro "ifz"-blk { "snz", blklen %1% }
macro "printstr"-unk { "push d0", reachchr %1% { "push CHAR_%0%" }, call printStr, "add sp d%strlen_1%" }
//macro "print"-unk { "push d0", "pushstr %1%", "call printstr" }

macro "ifkdn"-num-lab|"ifkdn"-mem-lab { "cmp int %1%", "jz _%2%" }
macro "ifeq"-nummem-nummem-lab { "cmp %1% %2%", "jz _%3%" }
macro "setkdn"-num-mem-num { "cmp int %1%", "snz 00000001", "mov %2% %3%" }

define osm_black 00000000
define osm_white 11111100
define osm_red 11000000
define osm_green 00110000
define osm_darkgreen 00010000

define terb d0

ckeys

~turbo terb
call osmRun
~end

funcrtn:
rtInt
~end

function osmRun {
  local cursel
  local curfg
  local curbg
  cursel = 00000001
  curbg = osm_darkgreen
  curfg = osm_green
  //~mov r6 osm_black
  //~mov r7 osm_white
  call osmDrawBG osm_black osm_white

  //~mov r0 d100
  //~mov r1 d20
  //~mov r7 osm_white
  //call makeColr
  //pushstr LOADING...
  //call printstr
  //~sub sp d11
  osmRun_int:
  //~mov r6 curbg
  //~mov r7 curfg
  call osmDrawBG curbg curfg
 
  point d6 d0  

  ~add r1 d5
  printstr END

  ~mov r0 d6
  ~add r1 d5
  printstr RND

  ~mov r0 d6
  ~add r1 d5
  //FOREGROUND
  printstr FG

  ~mov r0 d6
  ~add r1 d5
  //BACKGROUND
  printstr BG

  osmRunLp:
  //~mov r7 curbg
  call makeColr curbg
  rct d3 d3 d2 d100
  
  //~mov r7 curfg
  call makeColr curfg
  point d3 d1
  
  //~mov r7 cursel
  call osmDrawSelCur cursel
  
  ~and int 01111111
  osmRunInput:
  ~cmp int 00000000
  ~jz _osmRunInput
  ~mov r7 int
  ~mov int d0
  ~cmp r7 00000001
  ~snz d1
  cursel - d1
  ~cmp r7 00000100
  ~snz d1
  cursel + d1

  ~cmp cursel d0
  ~snz d1
  ~mov cursel d1

  ~cmp r7 00000101
  ~jnz _osmRunLp
  ~mov r7 cursel
  // EXIT
  ~cmp r7 d1
  ~jz _osmEnd
  // RNDCLR
  ~cmp r7 d2
  ~jz _osmRun_rndclr
  // EDTFG
  ~cmp r7 d3
  ~jz _osmRun_edtfg
  ~cmp r7 d4
  ~jz _osmRun_edtbg
  goto osmRun_int

  osmRun_rndclr:
  ~mov r6 bp
  ~sub r6 *curfg
  ~mov r7 bp
  ~sub r7 *curbg
  call osmRndClr
  goto osmRun_int

  osmRun_edtfg:
  ~mov r7 bp
  ~sub r7 *curfg
  call osmEdtClr
  goto osmRun_int

  osmRun_edtbg:
  ~mov r7 bp
  ~sub r7 *curbg
  call osmEdtClr
  goto osmRun_int

  osmEnd:
  ~turbo d0
}

function osmEdtClr {
  local curclrptr
  local curclor
  local curswt
  curswt = d0
  ~mov curclrptr r7
  osmEdtClr_lp:
  ~mov r6 curclrptr
  ~mov r7 [r6] 
  ~mov curclor r7
  rgb d0 d0 d0
  rct d98 d98 d25 d16
  call makeColr
  rct d100 d100 d10 d10
  point d111 d106
  ~mov r7 curclor
  ~and r7 11000000
  call makeColr
  printstr R
  ~mov r7 curclor
  ~and r7 00110000
  call makeColr
  printstr G
  ~mov r7 curclor
  ~and r7 00001100
  call makeColr
  printstr B
  rgb d255 d255 d255
  point d107 d112
  ~mov r7 d0
  osmEdtClr_mcrs:
  ~cmp r7 curswt
  ~sz d3
  ~add r7 d1
  ~add r0 d4
  ~jmp _osmEdtClr_mcrs
  paint
  ~add r0 d2
  paint
  ~sub r0 d1
  ~sub r1 d1
  paint
  osmEdtClr_inp:
  ~mov r7 int
  ~mov int d0
  ~cmp r7 00000000
  ~jz _osmEdtClr_inp
  ~cmp r7 K_WEST
  ~snz d1
  curswt - d1
  ~cmp r7 K_EAST
  ~snz d1
  curswt + d1
  ~cmp r7 K_NORTH
  ~jz _osmEdtClr_inc
  ~cmp r7 K_SOUTH
  ~jz _osmEdtClr_dec
  ~cmp r7 K_CNTR
  ~jz _osmEdtClr_rtn
  ~cmp curswt 11111111
  ~snz d1
  ~mov curswt d0
  ~cmp curswt d5
  ~snz d1
  ~mov curswt d4
  goto osmEdtClr_lp
  ~end
  osmEdtClr_inc:
  ~mov r7 curclor
  ~mov r6 r7
  ~cmp curswt d1
  ~snz d4
  ~add r7 01000000
  ~and r7 11000000
  ~and r6 00111100
  ~or r7 r6
  ~cmp curswt d2
  ~snz d4
  ~add r7 00010000
  ~and r7 00110000
  ~and r6 11001100
  ~or r7 r6
  ~cmp curswt d3
  ~snz d4
  ~add r7 00000100
  ~and r7 00001100
  ~and r6 11110000
  ~or r7 r6
  goto osmEdtClr_sav
  osmEdtClr_dec:
  ~mov r7 curclor
  ~mov r6 r7
  ~cmp curswt d1
  ~snz d4
  ~sub r7 01000000
  ~and r7 11000000
  ~and r6 00111100
  ~or r7 r6
  ~cmp curswt d2
  ~snz d4
  ~sub r7 00010000
  ~and r7 00110000
  ~and r6 11001100
  ~or r7 r6
  ~cmp curswt d3
  ~snz d4
  ~sub r7 00000100
  ~and r7 00001100
  ~and r6 11110000
  ~or r7 r6
  goto osmEdtClr_sav
  osmEdtClr_sav:
  ~mov r6 curclrptr
  ~mov [r6] r7
  goto osmEdtClr_lp
  osmEdtClr_rtn:
}

function osmRndClr {
  ~rnd
  ~mov [r6] r0
  ~rnd
  ~mov [r7] r0
}

function osmDrawSelCur {
  ~mov r6 d0
  ~:_osmDSC_cmp
  ~cmp r6 r7
  ~jz _osmDSC_eq
  ~add r6 d1
  ~add r1 d5
  ~jmp _osmDSC_cmp
  ~:_osmDSC_eq
  ~pnt
  ~add r1 d2
  ~pnt
  ~add r0 d1
  ~sub r1 d1
  ~pnt
  ~sub r0 d1
  ~sub r1 d1
}

function osmDrawBG {
  local bgCol
  local fgCol
  ~mov bgCol r6
  ~mov fgCol r7
  ~mov r7 bgCol
  call makeColr
  rct d1 d1 d254 d254
  ~mov r7 fgCol
  call makeColr
  rct d0 d0 d2 d255
  rct d1 d0 d255 d2
  rct d0 d254 d255 d2
  rct d254 d1 d2 d255
}
function makeColr {
  local bCol
  ~mov bCol r7  
  ~mov r2 r7
  ~and r2 11000000
  ~mov r3 r7
  ~shl r3 d2
  ~and r3 11000000
  ~mov r4 r7
  ~shl r4 d4
  ~and r4 11000000
}

// I'm lazy, clean up your own stack. ('add sp dStringLen+1' after func ret)
function printStr {
  local curchr
  curchr = d3
  ~turbo d20
  ~:_printstr_lp
  curchr + d1
  ~mov r7 curchr
  ~mov r6 [bp + r7]
  ~cmp r6 d0
  ~jz _printstr_end
  
  call printchr
  ~jmp _printstr_lp
  ~:_printstr_end
  ~turbo terb
}
macro "char4map"-num-mem-num-mem-num {"cmp r6 %1%", "snz d3", "mov %2% %3%", "mov %4% %5%", "jmp _printchr_parts"}
function printchr {
  local prta
  local prtb
  ~cmp r6 d32
  ~snz d2
  ~add r0 d4
  ~jmp _printchr_nd
  ~cmp r6 CHAR_.
  ~jz _printchr_dot
  char4map CHAR_E prta 11101000 prtb 11001110
  char4map CHAR_T prta 11100100 prtb 01000100
  char4map CHAR_A prta 01001010 prtb 11101010
  char4map CHAR_O prta 11101010 prtb 10101110
  char4map CHAR_I prta 11100100 prtb 01001110
  char4map CHAR_N prta 11001010 prtb 10101010
  char4map CHAR_S prta 01101100 prtb 00101100
  char4map CHAR_H prta 10101010 prtb 11101010
  char4map CHAR_R prta 11001010 prtb 11001010
  char4map CHAR_D prta 11001010 prtb 10101100
  char4map CHAR_L prta 10001000 prtb 10001110
  char4map CHAR_U prta 10101010 prtb 10101110
  char4map CHAR_C prta 01101000 prtb 10000110
  char4map CHAR_M prta 11101110 prtb 10101010
  char4map CHAR_F prta 11101000 prtb 11001000
  char4map CHAR_W prta 10101010 prtb 11101110
  char4map CHAR_G prta 01101000 prtb 11100110
  char4map CHAR_B prta 11001100 prtb 10101110
  char4map CHAR_K prta 10101100 prtb 10101010
  char4map CHAR_X prta 10101010 prtb 01001010
  char4map CHARGT prta 10000100 prtb 01101000
  ~mov prta 01001000
  ~mov prtb 00100100
  printchr_parts:
  ~mov r7 d0
  printchr_partalp:
  ~mov r6 prta
  ~shl r6 r7
  ~add r7 d1
  ~and r6 10000000
  ~cmp r6 10000000
  ~snz d1
  ~pnt
  ~add r0 d1
  ~cmp r7 d4
  ~snz d2
  ~sub r0 d4
  ~add r1 d1
  ~cmp r7 d9
  ~jl _printchr_partalp
  ~sub r0 d5
  ~add r1 d1
  ~mov r7 d0
  printchr_partblp:
  ~mov r6 prtb
  ~shl r6 r7
  ~add r7 d1
  ~and r6 10000000
  ~cmp r6 10000000
  ~snz d1
  ~pnt
  ~add r0 d1
  ~cmp r7 d4
  ~snz d2
  ~sub r0 d4
  ~add r1 d1
  ~cmp r7 d9
  ~jl _printchr_partblp
  ~sub r1 d3
  ~sub r0 d1
  goto printchr_nd
  printchr_dot:
  ~add r0 d1
  ~add r1 d3
  ~pnt
  ~add r0 d2
  ~sub r1 d3
  printchr_nd:
}
-->